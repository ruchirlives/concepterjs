import { useRef } from "react";
import toast from 'react-hot-toast';
import { useAppContext } from '../AppContext';
import * as api from "../api";
import { handleWriteBack, requestRefreshChannel } from "./effectsShared";
import { displayContextMenu, requestAddChild } from "./flowFunctions";
import { useMenuHandlers } from "./useContextMenu";

// Explicit handler map to avoid eval and ensure bundlers keep references
const HANDLERS = {
    insertNode,
    getContainerBudgetAction,
    convertToBudgetContainerAction,
    addFinanceContainerAction,
    rename,
    view,
    deleteAction,
    removeAction,
    copyToClipboard,
    hideUnselected,
    hideChildren,
    embedContainers,
    showChildren,
    showParents,
    categorize,
    buildRelationships,
    exportToTTS,
    exportSelected,
    exportBranchSelected,
    mergeSelected,
    joinSelected,
    addSelected,
    addSimilar,
    joinSimilar,
    buildChainBeam,
    renameFromDescription,
    removeFromSelectedParent,
    makeGroupNode,
    unmakeGroupNode,
    makeInputNode,
    unmakeInputNode,
    makeOutputNode,
    unmakeOutputNode,
    addLayerTag,
    removeLayerTag,
    createLayerFromVisible,
    embedPositionsAction,
    findSimilarPositionsAction,
    searchPositionZAction,
    inheritPositionsAction,
    convertToTagAction
};

export const menuItems = [
    // Basics
    { handler: "view", label: "View Details", group: "Basics" },
    { handler: "rename", label: "Rename", group: "Basics" },
    { handler: "copyToClipboard", label: "Copy to Clipboard", group: "Basics" },
    { handler: "deleteAction", label: "Delete", group: "Basics" },
    { handler: "removeAction", label: "Remove from Project", group: "Basics" },

    // Visibility
    { handler: "hideUnselected", label: "Hide Unselected", group: "Visibility" },
    { handler: "hideChildren", label: "Hide Children", group: "Visibility" },
    { handler: "showChildren", label: "Show Children", group: "Visibility" },
    { handler: "showParents", label: "Show Parents", group: "Visibility" },
    { handler: "createLayerFromVisible", label: "Create Layer from Visible", group: "Visibility" },

    // Analysis
    { handler: "categorize", label: "Categorize Containers", group: "Analyze" },
    { handler: "buildRelationships", label: "Build Relationships", group: "Analyze" },

    // Combine
    { handler: "mergeSelected", label: "Merge Selected", group: "Combine" },
    { handler: "joinSelected", label: "Join Selected", group: "Combine" },
    { handler: "joinSimilar", label: "Join Top Similar", group: "Combine" },
    { handler: "addSelected", label: "Add Selected", group: "Combine" },
    { handler: "addSimilar", label: "Add Similar", group: "Combine" },
    { handler: "insertNode", label: "Insert Node", group: "Combine" },

    // AI
    { handler: "buildChainBeam", label: "Build Chain Beam", group: "AI" },
    { handler: "renameFromDescription", label: "Rename from Description", group: "AI" },

    // Positions
    { handler: "embedContainers", label: "Embed Containers", group: "Positions" },
    { handler: "embedPositionsAction", label: "Embed Positions", group: "Positions" },
    { handler: "findSimilarPositionsAction", label: "Find Similar Positions", group: "Positions" },
    { handler: "searchPositionZAction", label: "Search Position Z", group: "Positions" },
    { handler: "inheritPositionsAction", label: "Inherit Positions (from Children)", group: "Positions" },

    // Groups
    { handler: "removeFromSelectedParent", label: "Remove from Selected Parent", group: "Groups" },
    { handler: "makeGroupNode", label: "Make Group Node", group: "Node Type" },
    { handler: "unmakeGroupNode", label: "Unmake Group Node", group: "Node Type" },
    { handler: "makeInputNode", label: "Make Input Node", group: "Node Type" },
    { handler: "unmakeInputNode", label: "Unmake Input Node", group: "Node Type" },
    { handler: "makeOutputNode", label: "Make Output Node", group: "Node Type" },
    { handler: "unmakeOutputNode", label: "Unmake Output Node", group: "Node Type" },
    { handler: "convertToTagAction", label: "Convert to Tag", group: "Node Type" },

    // Finance
    { handler: "getContainerBudgetAction", label: "Get Container Budget", group: "Finance" },
    { handler: "convertToBudgetContainerAction", label: "Convert to Budget Container", group: "Finance" },
    { handler: "addFinanceContainerAction", label: "Add Finance Container", group: "Finance" },

    // Export
    { handler: "exportToTTS", label: "Export to TTS", group: "Export" },
    { handler: "exportSelected", label: "Export Selected", group: "Export" },
    { handler: "exportBranchSelected", label: "Export Branch", group: "Export" },
    { handler: "exportApp", label: "Export to App", group: "Export" }
];

// FUNCTIONS *****************************************
/* eslint-disable no-unused-vars */

async function insertNode({ nodeId, selectedIds, selectedContentLayer, rowData, setRowData }) {
    // First create new node
    const newNodeName = prompt("Enter name for the new node:");
    if (!newNodeName) return;
    // Ensure Tags is always a string for downstream code that calls .split
    const tags = selectedContentLayer ? String(selectedContentLayer) : ""
    console.log("Creating new node with tags:", tags);
    const newId = await api.createContainer();

    // Add to rowData
    if (newId) {
        const newRow = {
            id: newId,
            Name: newNodeName,
            Description: "",
            Tags: tags
        };
        rowData.push(newRow);
        setRowData([...rowData]);
    }
    await handleWriteBack(rowData);

    console.log("New node created with id:", newId);
    // Continue to rewire relationships if applicable
    if (!newId) {
        alert("Failed to create new node.");
        return;
    }
    // Next, remove relationships from nodeId to selectedIds
    const ok = await api.removeChildren(nodeId, selectedIds);
    if (!ok) {
        alert("Failed to remove relationships from original node.");
        return;
    }
    // Now, add relationships from nodeId to newNode, and from newNode to selectedIds
    const ok1 = await api.addChildren(nodeId, [newId]);
    const ok2 = await api.addChildren(newId, selectedIds);
    if (!ok1 || !ok2) {
        alert("Failed to add relationships.");
        return;
    }
    await requestRefreshChannel();
}

async function getContainerBudgetAction({ selectedIds }) {
    if (!selectedIds.length) {
        toast.error("No containers selected.");
        return;
    }
    const budgets = await api.getContainerBudgetApi(selectedIds);
    if (!budgets.length) {
        toast("No budgets found for selected containers.");
        return;
    }
    let msg = budgets.map(b => `ID: ${b.Name} â€” Budget: ${b.Budget}`).join('\n');
    toast(msg, { duration: 8000 });
}

async function convertToBudgetContainerAction({ selectedIds }) {
    if (!selectedIds.length) {
        toast.error("No containers selected.");
        return;
    }
    const res = await api.convertToBudgetContainerApi(selectedIds);
    toast.success(res.message || "Converted to budget container.");
    requestRefreshChannel();
}

async function addFinanceContainerAction({ selectedIds }) {
    if (!selectedIds.length) {
        toast.error("No containers selected.");
        return;
    }
    const res = await api.addFinanceContainerApi(selectedIds);
    toast.success(res.message || "Converted to finance container.");
    requestRefreshChannel();
}

// rename
async function rename({ selectedNodes, selectedIds, rowData, setRowData }) {
    if (selectedNodes.length === 0) {
        toast.error("No nodes selected to rename.");
        return;
    }
    const name = prompt("Enter new name for the selected node(s):");
    if (!name) return;

    // Update the nodes in rowData
    const updatedRowData = rowData.map(row =>
        selectedIds.includes(row.id) ? { ...row, Name: name } : row
    );
    setRowData(updatedRowData);

    // Optionally update selectedNodes too
    selectedNodes.forEach(node => {
        if (selectedIds.includes(node.data.id)) {
            node.data.Name = name;
        }
    });

    handleWriteBack(updatedRowData);
    toast.success("Node(s) renamed successfully!");
}


async function view({ nodeId, selectedNodes }) {
    console.log(`View details for Node ID: ${nodeId}`);
    console.log("Active node's data:", selectedNodes[0]);
}

async function deleteAction({ selectedIds }) {
    // first confirm
    if (!window.confirm(`Are you sure you want to delete ${selectedIds.length} container(s)? This action cannot be undone.`)) {
        return;
    }
    const ok = await api.deleteContainers(selectedIds);
    if (ok) requestRefreshChannel();
    else alert("Failed to delete containers.");
}

async function removeAction({ selectedIds }) {
    const ok = await api.removeContainers(selectedIds);
    if (ok) requestRefreshChannel();
    else alert("Failed to remove containers.");
}

async function copyToClipboard({ selectedNodes }) {
    if (!selectedNodes || selectedNodes.length === 0) {
        toast.error("No nodes selected to copy.");
        return;
    }
    try {
        // Copy only the Name text of each selected node
        const text = selectedNodes.map(n => n.data.Name).join('\n');
